<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OverVolt | Ultimate Master V16 (Final Revisions)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;800;900&family=Space+Mono:ital,wght@0,400;0,700;1,400&display=swap');
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        body { background-color: #030303; color: #e0e0e0; font-family: 'Inter', sans-serif; overflow-x: hidden; }
        canvas { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: -1; pointer-events: none; background: repeating-linear-gradient(0deg, rgba(0, 0, 0, 0.1) 0px, rgba(0, 0, 0, 0.1) 1px, transparent 1px, transparent 2px); }
        
        /* RENKLER */
        :root { --main-color: #00ff88; --elec-color: #00aaff; --adas-color: #ff0055; --uni-color: #00d2d3; }
        
        section { width: 100%; position: relative; padding: 0 5vw; display: flex; flex-direction: column; }

        /* 1. SAYFA */
        #intro-section { height: 100vh; justify-content: center; align-items: center; z-index: 20; }
        .huge-intro-title { font-family: 'Inter', sans-serif; font-size: clamp(3.5rem, 12vw, 15rem); font-weight: 900; text-transform: uppercase; letter-spacing: -0.08em; line-height: 0.8; text-align: center; color: #fff; }
        .scroll-hint { font-family: 'Space Mono', monospace; color: var(--main-color); font-size: 10px; letter-spacing: 3px; animation: blink 2s infinite; position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%); }

        /* VİTRİN SAYFALARI */
        #showcase-section, #electronics-section, #adas-section, #team-showcase-section { height: 100vh; justify-content: center; align-items: flex-start; z-index: 10; }
        .showcase-wrapper { margin-left: 5vw; width: 50%; position: relative; z-index: 30; }
        .titles-container { display: flex; flex-direction: column; align-items: flex-start; }
        h1.main-heading { font-family: 'Inter', sans-serif; font-size: clamp(3rem, 9vw, 8rem); font-weight: 900; line-height: 0.9; text-transform: uppercase; letter-spacing: -0.08em; color: #fff; margin: 0; transform-origin: top left; }
        h2.sub-heading { font-family: 'Inter', sans-serif; font-size: clamp(1.5rem, 4vw, 3.5rem); font-weight: 800; text-transform: uppercase; letter-spacing: -0.05em; color: var(--main-color); margin: 0; margin-left: 5px; position: relative; }
        p.subtitle { font-family: 'Space Mono', monospace; font-size: 0.9rem; margin-top: 2rem; max-width: 450px; line-height: 1.6; color: #b0b0b0; border-left: 3px solid var(--main-color); padding-left: 20px; background: linear-gradient(90deg, rgba(0,255,136,0.1) 0%, rgba(0,0,0,0) 100%); }

        /* DETAY SAYFALARI */
        #details-section, #electronics-details-section, #adas-details-section, #team-details-section { min-height: 100vh; justify-content: flex-start; z-index: 15; padding-top: 45vh; padding-left: 5vw; }
        .details-content { width: 100%; max-width: 650px; opacity: 0; transform: translateY(50px); }
        .tech-paragraph { font-family: 'Space Mono', monospace; font-size: 0.9rem; line-height: 1.6; color: #ccc; margin-bottom: 2rem; border-left: 1px solid rgba(0, 255, 136, 0.3); padding-left: 20px; }
        .tech-specs { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 30px; }
        .spec-item h4 { font-family: 'Inter', sans-serif; color: var(--main-color); margin-bottom: 5px; font-size: 0.8rem; }
        .spec-item p { font-family: 'Space Mono', monospace; font-size: 0.75rem; color: #888; }

        /* RENK VE STİL ÖZELLEŞTİRMELERİ */
        #electronics-details-section .tech-paragraph { border-color: var(--elec-color); margin-bottom: 1.5rem; }
        #electronics-details-section strong { color: var(--elec-color); letter-spacing: 1px; }
        
        #adas-details-section .tech-paragraph { border-color: var(--adas-color); margin-bottom: 1.5rem; }
        #adas-details-section strong { color: var(--adas-color); letter-spacing: 1px; }

        #team-details-section .tech-paragraph { border-color: var(--uni-color); margin-bottom: 1.5rem; }
        #team-details-section strong { color: var(--uni-color); letter-spacing: 1px; }

        /* HUD ve LOGO */
        .ui-container-fixed { position: fixed; top: 0; left: 0; width: 100%; height: 100vh; z-index: 40; pointer-events: none; opacity: 0; }
        .hud { position: fixed; font-family: 'Space Mono', monospace; font-size: 9px; color: var(--main-color); opacity: 0.7; padding: 5px; background: rgba(0, 20, 10, 0.5); border: 1px solid rgba(0, 255, 136, 0.2); }
        .hud-tl { top: 20px; left: 20px; border-left: 3px solid var(--main-color); }
        .hud-tr { top: 20px; right: 20px; text-align: right; border-right: 3px solid var(--main-color); }
        .hud-bl { bottom: 20px; left: 20px; border-left: 3px solid var(--main-color); }
        .hud-br { bottom: 20px; right: 20px; text-align: right; border-right: 3px solid var(--main-color); }
        .fixed-logo { position: fixed; top: 35px; left: 35px; font-family: 'Inter', sans-serif; font-weight: 900; font-size: 1.2rem; color: #fff; z-index: 50; opacity: 0; pointer-events: none; }

        /* EFEKTLER */
        .glitch-text { position: relative; display: inline-block; }
        .glitch-text::before, .glitch-text::after { content: attr(data-text); position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; }
        .glitch-text::before { color: var(--main-color); animation: glitch-effect 3s infinite linear alternate-reverse; clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%); transform: translate(-2px, 2px); opacity: 0.7; }
        .glitch-text::after { color: #ffffff; animation: glitch-effect 2.5s infinite linear alternate; clip-path: polygon(0 55%, 100% 55%, 100% 100%, 0 100%); transform: translate(2px, -2px); opacity: 0.5; }
        @keyframes glitch-effect { 0% { transform: translate(0); } 20% { transform: translate(-2px, 2px); } 40% { transform: translate(-1px, -1px); } 60% { transform: translate(2px, 1px); } 80% { transform: translate(1px, -2px); } 100% { transform: translate(0); } }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }

        /* MOBİL UYUM */
        @media screen and (max-width: 768px) {
            .showcase-wrapper { width: 100%; margin-left: 0; text-align: center; margin-top: 10vh; }
            .titles-container { align-items: center; }
            h1.main-heading { transform-origin: center top; font-size: 12vw; }
            h2.sub-heading { font-size: 6vw; }
            p.subtitle { margin: 2rem auto; text-align: center; font-size: 0.85rem; border-left: none; border-bottom: 2px solid var(--main-color); padding-bottom: 10px; padding-left: 0; }
            .hud-tl, .hud-tr { display: none; }
            .fixed-logo { left: 50%; transform: translateX(-50%); font-size: 1rem; top: 20px; }
            #details-section, #electronics-details-section, #adas-details-section, #team-details-section { padding-top: 30vh; }
            .tech-specs { grid-template-columns: 1fr; }
            .glitch-text::before, .glitch-text::after { display: none; }
        }
    </style>
</head>
<body>
    <canvas id="gl"></canvas>
    <div class="fixed-logo">OVER<span style="color: var(--main-color)">VOLT</span></div>

    <div class="ui-container-fixed">
        <div class="hud hud-tl" style="top: 80px;">DIVISION:<br><span id="hud-div">MECHANICS</span></div>
        <div class="hud hud-tr">MAT: <span id="hud-mat">CFRP_COMPOSITE</span><br>STATUS: NOMINAL</div>
        <div class="hud hud-bl">ID: OV-X1<br>MODE: ACTIVE</div>
        <div class="hud hud-br">SYS<br>ONLINE</div>
    </div>

    <section id="intro-section">
        <h1 class="huge-intro-title glitch-text" data-text="OVERVOLT">OVER<span style="color: var(--main-color);">VOLT</span></h1>
        <div class="scroll-hint">SCROLL TO REVEAL</div>
    </section>

    <section id="showcase-section">
        <div class="showcase-wrapper">
            <div class="titles-container">
                <h1 class="main-heading glitch-text" data-text="OVERVOLT">OVERVOLT</h1>
                <h2 class="sub-heading glitch-text" data-text="MECHANICS">MECHANICS</h2>
            </div>
            <p class="subtitle">
                Ham metalin soğukluğu, aklın ateşiyle dövüldü. Henüz bir kaportası yok çünkü ruhu, çıplak mekaniğinde saklı.
            </p>
        </div>
    </section>

    <section id="details-section">
        <div class="details-content">
            <p class="tech-paragraph"><strong>// ŞASİ GEOMETRİSİ VE DİNAMİKLERİ:</strong><br>Aracımız, Shell Eco-marathon Prototype kategorisi standartlarına tam uyum sağlayan, 2 ön ve 1 arka tekerlekten oluşan yenilikçi "tadpole" konfigürasyonuna sahiptir. Bu geometri, düşük hızlarda üstün manevra kabiliyeti sunarken, yüksek hızlarda aerodinamik stabiliteyi maksimize eder. Entegre alüminyum alaşımlı takla kafesi, pilot güvenliğini en üst seviyeye taşır.</p>
            <p class="tech-paragraph"><strong>// İLERİ MATERYAL BİLİMİ (CFRP):</strong><br>Şasi üretiminde, havacılık ve uzay endüstrisinde kullanılan yüksek modüllü Karbon Fiber Takviyeli Polimer (CFRP) kompozitler tercih edilmiştir. Vakum infüzyon tekniği ile üretilen monokok gövde, geleneksel çelik şasilere göre %40 daha hafif olmasına rağmen 3 kat daha yüksek çekme dayanımı sunar.</p>
            <div class="tech-specs">
                <div class="spec-item"><h4>TOPLAM AĞIRLIK</h4><p>&lt; 28kg (Pilot Hariç)</p></div>
                <div class="spec-item"><h4>AERODİNAMİK SÜRTÜNME</h4><p>Cd: 0.11 (Rüzgar Tüneli Verisi)</p></div>
                <div class="spec-item"><h4>YÜKSEK VOLTAJ BATARYA</h4><p>48V 20Ah Li-Ion (NMC Hücreler)</p></div>
                <div class="spec-item"><h4>GÜÇ AKTARIM SİSTEMİ</h4><p>Tek Kademeli Redüktör & Zincir Tahrik</p></div>
            </div>
        </div>
    </section>

    <section id="electronics-section">
        <div class="showcase-wrapper">
            <div class="titles-container">
                <h1 class="main-heading glitch-text" data-text="OVERVOLT">OVERVOLT</h1>
                <h2 class="sub-heading glitch-text" data-text="ELECTRONICS" style="color: #00aaff;">ELECTRONICS</h2>
            </div>
            <p class="subtitle" style="border-color: #00aaff; background: linear-gradient(90deg, rgba(0,170,255,0.1) 0%, rgba(0,0,0,0) 100%);">
                Silikonun zekası, bakırın hızı. Aracın sinir sistemi, milisaniyeler içinde karar veren dijital bir beyin.
            </p>
        </div>
    </section>

    <section id="electronics-details-section">
        <div class="details-content">
            <p class="tech-paragraph"><strong>// GELİŞMİŞ MOTOR SÜRÜCÜ (FOC):</strong><br>Kendi tasarımımız olan motor sürücü, Alan Yönlendirmeli Kontrol (FOC) algoritmasını kullanarak motorun her anında optimum tork ve verimlilik sağlar. Sinüzoidal akım sürüşü sayesinde tork dalgalanmaları minimize edilir, sessiz ve pürüzsüz bir sürüş deneyimi sunulur.</p>
            <p class="tech-paragraph"><strong>// AKILLI BATARYA YÖNETİMİ (BMS) & OBC:</strong><br>13S konfigürasyonundaki Li-Ion batarya paketi, aktif dengeleme özelliğine sahip gelişmiş bir BMS tarafından izlenir. Her bir hücrenin voltajı ve sıcaklığı kontrol altında tutulur. Entegre Yerleşik Şarj Cihazı (OBC), güvenli şarj sağlar.</p>
            <p class="tech-paragraph"><strong>// ENERJİ YÖNETİM SİSTEMİ (EYS):</strong><br>Araç üzerindeki farklı gerilim ihtiyaçları, yüksek verimli izole Buck konvertörler tarafından karşılanır. Merkezi Araç Kontrol Sistemi (AKS), telemetri verilerini pit ekibine aktarır.</p>
            <p class="tech-paragraph"><strong>// GÜVENLİK VE KORUMA:</strong><br>Tüm alt sistemler CAN-BUS protokolü ile haberleşir. Aşırı akım ve voltaj durumlarında sistem kendini milisaniyeler içinde korumaya alır.</p>
        </div>
    </section>

    <section id="adas-section">
        <div class="showcase-wrapper">
            <div class="titles-container">
                <h1 class="main-heading glitch-text" data-text="OVERVOLT">OVERVOLT</h1>
                <h2 class="sub-heading glitch-text" data-text="ADAS" style="color: var(--adas-color);">ADAS AI</h2>
            </div>
            <p class="subtitle" style="border-color: var(--adas-color); background: linear-gradient(90deg, rgba(255,0,85,0.1) 0%, rgba(0,0,0,0) 100%);">
                Görünenin ötesini algıla. Lidar ve sensör füzyonu ile 360 derece çevresel farkındalık. Yapay zeka destekli otonom karar mekanizması.
            </p>
        </div>
    </section>

    <section id="adas-details-section">
        <div class="details-content">
            <p class="tech-paragraph"><strong>// ŞERİT TAKİP SİSTEMİ (LKA):</strong><br>Yüksek çözünürlüklü kameralar ve görüntü işleme algoritmaları ile yol çizgilerini mikrosaniye hassasiyetinde algılar.</p>
            <p class="tech-paragraph"><strong>// ADAPTİF HIZ SABİTLEME (ACC):</strong><br>Ön radar sensörü ile trafik akışını ve öndeki araç mesafesini sürekli ölçer. Hızı otomatik olarak ayarlar.</p>
            <p class="tech-paragraph"><strong>// OTONOM ACİL FRENLEME (AEB):</strong><br>Lidar ve kamera sensör füzyonu sayesinde yaya, bisikletli veya ani duran araçları algılar ve otomatik frenler.</p>
            <p class="tech-paragraph"><strong>// AI GÜÇ OPTİMİZASYONU:</strong><br>Araç, rota üzerindeki eğim verilerini ve anlık trafik durumunu analiz ederek enerji tüketimini %15 düşürür.</p>
        </div>
    </section>

    <section id="team-showcase-section">
        <div class="showcase-wrapper">
            <div class="titles-container">
                <h1 class="main-heading glitch-text" data-text="OVERVOLT">OVERVOLT</h1>
                <h2 class="sub-heading glitch-text" data-text="THE TEAM" style="color: var(--uni-color);">THE TEAM</h2>
            </div>
            <p class="subtitle" style="border-color: var(--uni-color); background: linear-gradient(90deg, rgba(0, 210, 211, 0.1) 0%, rgba(0,0,0,0) 100%);">
                Tutku, mühendislik ve inovasyonun buluşma noktası. Geleceğin teknolojilerini bugünden tasarlayan genç ve dinamik bir ekip.
            </p>
        </div>
    </section>

    <section id="team-details-section">
        <div class="details-content">
            <p class="tech-paragraph"><strong>// BİZ KİMİZ?</strong><br>Bizler, İstanbul Medeniyet Üniversitesi bünyesinde, sürdürülebilir bir gelecek vizyonuyla bir araya gelmiş, mühendislik tutkusuyla yanan bir ekibiz. Dönem başında kurulan takımımız, farklı disiplinlerden gelen yetenekli mühendis adaylarının ortak hayali olan "kendi imkanlarımızla geliştirdiğimiz yüksek verimli elektrikli araç" projesini hayata geçirmek için gece gündüz çalışmaktadır.</p>
            <p class="tech-paragraph"><strong>// MİSYONUMUZ:</strong><br>Teorik bilgiyi pratik deneyimle harmanlayarak, enerji verimliliği konusunda sınırları zorlayan, Shell Eco-marathon gibi uluslararası arenada ülkemizi ve üniversitemizi en iyi şekilde temsil edecek inovatif araçlar tasarlamak ve üretmektir.</p>
            <p class="tech-paragraph"><strong>// VİZYONUMUZ:</strong><br>Sadece bir araç üretmek değil, aynı zamanda geleceğin otomotiv teknolojilerine yön verecek mühendisler yetiştiren, AR-GE kültürüyle yoğrulmuş, sürdürülebilir bir inovasyon ekosistemi oluşturmaktır.</p>
        </div>
    </section>

    <div style="height: 50vh;"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>

    <script>
        const canvas = document.querySelector('#gl'); const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        const renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // --- SHADERS ---
        const vertexShader = `varying vec2 vUv; varying vec3 vNormal; varying vec3 vPos; uniform float uTime; void main() { vUv = uv; vNormal = normalize(normalMatrix * normal); vec3 pos = position; float tension = sin(uTime * 2.0 + pos.x * 0.5) * 0.002; pos += normal * tension; vPos = (modelMatrix * vec4(pos, 1.0)).xyz; gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0); }`;
        const fragmentShaderBase = `varying vec2 vUv; varying vec3 vNormal; varying vec3 vPos; uniform vec3 uColor; uniform float uTime; uniform float uOpacity; float dither8x8(vec2 position, float brightness) { int x = int(mod(position.x, 8.0)); int y = int(mod(position.y, 8.0)); int index = x + y * 8; float limit = 0.0; if (index == 0) limit = 0.015625; if (index == 63) limit = 0.34375; if (x < 8) { if (index % 2 == 0) limit = 0.25; else limit = 0.75; } return brightness < limit ? 0.0 : 1.0; } void main() { vec3 lightDir = normalize(vec3(0.2, 1.0, 0.5)); float diff = max(dot(vNormal, lightDir), 0.0); vec3 viewDir = normalize(cameraPosition - vPos); float rim = 1.0 - abs(dot(viewDir, vNormal)); rim = pow(rim, 3.0); float combinedLight = diff * 0.4 + rim * 0.9; vec2 screenPos = gl_FragCoord.xy; float dither = dither8x8(screenPos, combinedLight); vec3 finalColor = uColor * dither; vec3 darkBG = vec3(0.01, 0.03, 0.01); vec4 colorOut; if(dither < 0.1) { float grid = step(0.98, fract(vPos.x * 2.0)) + step(0.98, fract(vPos.z * 2.0)); colorOut = vec4(mix(darkBG, uColor * 0.2, grid * 0.3), 1.0); } else { colorOut = vec4(finalColor, 1.0); } gl_FragColor = vec4(colorOut.rgb, colorOut.a * uOpacity); }`;
        const fragmentShaderPCB = `varying vec2 vUv; varying vec3 vNormal; varying vec3 vPos; uniform vec3 uColor; uniform float uTime; uniform float uOpacity; float dither8x8(vec2 position, float brightness) { int x = int(mod(position.x, 8.0)); int y = int(mod(position.y, 8.0)); int index = x + y * 8; float limit = 0.0; if (index == 0) limit = 0.015625; if (index == 63) limit = 0.34375; if (x < 8) { if (index % 2 == 0) limit = 0.25; else limit = 0.75; } return brightness < limit ? 0.0 : 1.0; } float circuitPattern(vec2 uv) { float size = 20.0; vec2 grid = floor(uv * size); vec2 sub = fract(uv * size); float line = step(0.4, sub.x) - step(0.6, sub.x) + step(0.4, sub.y) - step(0.6, sub.y); float via = step(length(sub - 0.5), 0.2); return max(line, via) * (mod(grid.x + grid.y, 2.0) * 0.5 + 0.5); } void main() { vec3 lightDir = normalize(vec3(0.2, 1.0, 0.5)); float diff = max(dot(vNormal, lightDir), 0.0); vec3 viewDir = normalize(cameraPosition - vPos); float rim = 1.0 - abs(dot(viewDir, vNormal)); rim = pow(rim, 3.0); float combinedLight = diff * 0.4 + rim * 0.9; float pattern = circuitPattern(vUv * vec2(2.0, 3.0)); vec2 screenPos = gl_FragCoord.xy; float dither = dither8x8(screenPos, combinedLight); vec3 finalColor = uColor * dither * (0.7 + pattern * 0.3); vec3 darkBG = vec3(0.01, 0.03, 0.01); vec4 colorOut; if(dither < 0.1) { float grid = step(0.98, fract(vPos.x * 2.0)) + step(0.98, fract(vPos.z * 2.0)); colorOut = vec4(mix(darkBG, uColor * 0.2, grid * 0.3), 1.0); } else { colorOut = vec4(finalColor, 1.0); } gl_FragColor = vec4(colorOut.rgb, colorOut.a * uOpacity); }`;
        const vertexShaderSparkExpanded = `uniform float uTime; attribute float aOffset; varying float vAlpha; float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); } void main() { vec3 pos = position; float t = mod(uTime * 2.0 + aOffset, 3.0); float life = 1.0 - smoothstep(0.0, 0.4, t); float noiseX = random(vec2(t, aOffset)) - 0.5; float noiseY = random(vec2(aOffset, t)) - 0.5; float noiseZ = random(vec2(t + aOffset, t)) - 0.5; pos += vec3(noiseX, noiseY, noiseZ) * life * 0.3; vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0); gl_PointSize = 25.0 * life * (10.0 / -mvPosition.z); vAlpha = life; gl_Position = projectionMatrix * mvPosition; }`;
        const fragmentShaderSpark = `uniform vec3 uColor; uniform float uOpacity; varying float vAlpha; void main() { float dist = length(gl_PointCoord - vec2(0.5)); float intensity = 1.0 - smoothstep(0.0, 0.5, dist); intensity = pow(intensity, 3.0); gl_FragColor = vec4(uColor, vAlpha * uOpacity * intensity); }`;
        const fragmentShaderADAS = `varying vec2 vUv; uniform vec3 uColor; uniform float uTime; uniform float uOpacity; void main() { float dist = length(vUv - 0.5); float wave = fract(dist * 6.0 - uTime * 1.5); float ring = smoothstep(0.4, 0.5, wave) * smoothstep(0.6, 0.5, wave); float brightness = 1.0 - smoothstep(0.0, 0.5, dist); vec3 finalColor = uColor * (ring + 0.1) * brightness; float alpha = smoothstep(0.5, 0.0, dist) * uOpacity; gl_FragColor = vec4(finalColor, alpha); }`;

        // --- MATERIALS ---
        const matSettings = { transparent: true, uniforms: { uTime: { value: 0 }, uOpacity: { value: 0.0 } } };
        const chassisMaterial = new THREE.ShaderMaterial({ vertexShader, fragmentShader: fragmentShaderBase, ...matSettings, uniforms: { ...matSettings.uniforms, uColor: { value: new THREE.Color("#00ff88") }, uOpacity: { value: 0.0 } } });
        const pcbBoardMat = new THREE.ShaderMaterial({ vertexShader, fragmentShader: fragmentShaderPCB, ...matSettings, uniforms: { ...matSettings.uniforms, uColor: { value: new THREE.Color("#004400") }, uOpacity: { value: 0.0 } } });
        const pcbChipMat = new THREE.ShaderMaterial({ vertexShader, fragmentShader: fragmentShaderBase, ...matSettings, uniforms: { ...matSettings.uniforms, uColor: { value: new THREE.Color("#111111") }, uOpacity: { value: 0.0 } } });
        const pcbSmdMat = new THREE.ShaderMaterial({ vertexShader, fragmentShader: fragmentShaderBase, ...matSettings, uniforms: { ...matSettings.uniforms, uColor: { value: new THREE.Color("#aa8866") }, uOpacity: { value: 0.0 } } });
        const pcbCopperMat = new THREE.ShaderMaterial({ vertexShader, fragmentShader: fragmentShaderBase, ...matSettings, uniforms: { ...matSettings.uniforms, uColor: { value: new THREE.Color("#b87333") }, uOpacity: { value: 0.0 } } });
        const pcbWireMatRed = new THREE.ShaderMaterial({ vertexShader, fragmentShader: fragmentShaderBase, ...matSettings, uniforms: { ...matSettings.uniforms, uColor: { value: new THREE.Color("#990000") }, uOpacity: { value: 0.0 } } });
        const pcbWireMatBlack = new THREE.ShaderMaterial({ vertexShader, fragmentShader: fragmentShaderBase, ...matSettings, uniforms: { ...matSettings.uniforms, uColor: { value: new THREE.Color("#222222") }, uOpacity: { value: 0.0 } } });
        const connSparkMat = new THREE.ShaderMaterial({ vertexShader: vertexShaderSparkExpanded, fragmentShader: fragmentShaderSpark, ...matSettings, uniforms: { ...matSettings.uniforms, uColor: { value: new THREE.Color("#00aaff") }, uOpacity: { value: 0.0 } }, blending: THREE.AdditiveBlending, depthWrite: false });
        const adasMat = new THREE.ShaderMaterial({ vertexShader, fragmentShader: fragmentShaderADAS, ...matSettings, uniforms: { ...matSettings.uniforms, uColor: { value: new THREE.Color("#ff0055") }, uOpacity: { value: 0.0 } }, blending: THREE.AdditiveBlending, side: THREE.DoubleSide });
        const adasCarMat = new THREE.ShaderMaterial({ vertexShader, fragmentShader: fragmentShaderBase, ...matSettings, uniforms: { ...matSettings.uniforms, uColor: { value: new THREE.Color("#ff0055") }, uOpacity: { value: 0.0 } } });
        const uniLogoMat = new THREE.ShaderMaterial({ vertexShader, fragmentShader: fragmentShaderBase, ...matSettings, uniforms: { ...matSettings.uniforms, uColor: { value: new THREE.Color("#00d2d3") }, uOpacity: { value: 0.0 } } });

        const main3DGroup = new THREE.Group(); scene.add(main3DGroup);

        // --- 1. MODEL: ŞASİ ---
        const chassisGroup = new THREE.Group(); main3DGroup.add(chassisGroup);
        function createSquareTube(p1, p2, thickness = 0.035, mat) { const vec = new THREE.Vector3().subVectors(p2, p1); const mid = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5); const geom = new THREE.BoxGeometry(thickness, thickness, vec.length()); const mesh = new THREE.Mesh(geom, mat); mesh.position.copy(mid); mesh.lookAt(p2); return mesh; }
        function buildChassis() { const group = new THREE.Group(); const wR = 0.65; const wF = 0.35; const hBottom = 0.0; const hTop = 0.45; const hRoll = 0.95; const zBack = -1.2; const zMid = 0.6; const zNose = 2.2; const pRB_L = new THREE.Vector3(-wR, hBottom, zBack); const pRB_R = new THREE.Vector3(wR, hBottom, zBack); const pRT_L = new THREE.Vector3(-wR, hTop, zBack); const pRT_R = new THREE.Vector3(wR, hTop, zBack); const pMB_L = new THREE.Vector3(-wR, hBottom, zMid); const pMB_R = new THREE.Vector3(wR, hBottom, zMid); const pMT_L = new THREE.Vector3(-wR, hTop, zMid); const pMT_R = new THREE.Vector3(wR, hTop, zMid); const pNB_L = new THREE.Vector3(-wF, 0.1, zNose); const pNB_R = new THREE.Vector3(wF, 0.1, zNose); const pNT_L = new THREE.Vector3(-wF, 0.3, zNose-0.2); const pNT_R = new THREE.Vector3(wF, 0.3, zNose-0.2); const pRoll_L = new THREE.Vector3(-0.3, hRoll, 0.2); const pRoll_R = new THREE.Vector3(0.3, hRoll, 0.2); group.add(createSquareTube(pRB_L, pRB_R, 0.035, chassisMaterial)); group.add(createSquareTube(pRB_L, pMB_L, 0.035, chassisMaterial)); group.add(createSquareTube(pRB_R, pMB_R, 0.035, chassisMaterial)); group.add(createSquareTube(pMB_L, pNB_L, 0.035, chassisMaterial)); group.add(createSquareTube(pMB_R, pNB_R, 0.035, chassisMaterial)); group.add(createSquareTube(pNB_L, pNB_R, 0.035, chassisMaterial)); group.add(createSquareTube(pRT_L, pRT_R, 0.035, chassisMaterial)); group.add(createSquareTube(pRB_L, pRT_L, 0.035, chassisMaterial)); group.add(createSquareTube(pRB_R, pRT_R, 0.035, chassisMaterial)); group.add(createSquareTube(pRT_L, pMT_L, 0.035, chassisMaterial)); group.add(createSquareTube(pRT_R, pMT_R, 0.035, chassisMaterial)); group.add(createSquareTube(pMB_L, pMT_L, 0.035, chassisMaterial)); group.add(createSquareTube(pMB_R, pMT_R, 0.035, chassisMaterial)); group.add(createSquareTube(pMT_L, pNT_L, 0.035, chassisMaterial)); group.add(createSquareTube(pMT_R, pNT_R, 0.035, chassisMaterial)); group.add(createSquareTube(pNT_L, pNT_R, 0.035, chassisMaterial)); group.add(createSquareTube(pNB_L, pNT_L, 0.035, chassisMaterial)); group.add(createSquareTube(pNB_R, pNT_R, 0.035, chassisMaterial)); group.add(createSquareTube(pMT_L, pRoll_L, 0.035, chassisMaterial)); group.add(createSquareTube(pMT_R, pRoll_R, 0.035, chassisMaterial)); group.add(createSquareTube(pRoll_L, pRoll_R, 0.035, chassisMaterial)); group.add(createSquareTube(pRT_L, pRoll_L, 0.035, chassisMaterial)); group.add(createSquareTube(pRT_R, pRoll_R, 0.035, chassisMaterial)); return group; }
        const chassisGroupReal = buildChassis(); chassisGroup.add(chassisGroupReal);

        // --- 2. MODEL: PCB ---
        const pcbGroup = new THREE.Group(); main3DGroup.add(pcbGroup); pcbGroup.scale.set(0,0,0);
        function buildDetailedPCB() {
            const group = new THREE.Group(); const boardW = 1.4; const boardH = 1.2;
            group.add(new THREE.Mesh(new THREE.BoxGeometry(boardW, 0.04, boardH), pcbBoardMat));
            const chipPositions = [{x:0, z:0, s:0.4}, {x:-0.4, z:0.3, s:0.25}, {x:0.4, z:-0.3, s:0.3}, {x:-0.5, z:-0.4, s:0.15}, {x:0.5, z:0.4, s:0.2}];
            chipPositions.forEach(pos => { const chip = new THREE.Mesh(new THREE.BoxGeometry(pos.s, 0.08, pos.s), pcbChipMat); chip.position.set(pos.x, 0.06, pos.z); group.add(chip); });
            const smdGeom = new THREE.BoxGeometry(0.04, 0.03, 0.08);
            for(let i=0; i<100; i++) { const smd = new THREE.Mesh(smdGeom, pcbSmdMat); let x = (Math.random() - 0.5) * 1.2; let z = (Math.random() - 0.5) * 1.0; if(Math.abs(x)<0.2 && Math.abs(z)<0.2) continue; smd.position.set(x, 0.04, z); if(Math.random()>0.5) smd.rotation.y = Math.PI/2; group.add(smd); }
            const coilGroup = new THREE.Group(); coilGroup.add(new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.15, 0.1), pcbChipMat));
            for(let i=0; i<8; i++) { const wrap = new THREE.Mesh(new THREE.TorusGeometry(0.07, 0.015, 8, 16), pcbCopperMat); wrap.rotation.y = Math.PI/2; wrap.position.x = -0.08 + i*0.022; coilGroup.add(wrap); }
            coilGroup.position.set(0.4, 0.1, 0.3); group.add(coilGroup);
            const connGeom = new THREE.BoxGeometry(0.15, 0.15, 0.3); const conn1 = new THREE.Mesh(connGeom, pcbSmdMat); conn1.position.set(-0.5, 0.08, 0); group.add(conn1);
            function createWire(points, mat) { const curve = new THREE.CatmullRomCurve3(points); const tube = new THREE.Mesh(new THREE.TubeGeometry(curve, 20, 0.02, 8, false), mat); group.add(tube); }
            createWire([new THREE.Vector3(-0.5, 0.15, 0), new THREE.Vector3(-0.7, 0.3, 0.2), new THREE.Vector3(-1.0, 0.1, 0.5)], pcbWireMatRed);
            createWire([new THREE.Vector3(-0.5, 0.15, -0.1), new THREE.Vector3(-0.8, 0.25, -0.3), new THREE.Vector3(-1.1, 0.0, -0.6)], pcbWireMatBlack);
            const sparkGeom = new THREE.BufferGeometry(); const sparkPositions = new Float32Array([-0.5, 0.15, 0.0,  -0.5, 0.15, -0.1]); const sparkOffsets = new Float32Array([0.0, 1.5]);
            sparkGeom.setAttribute('position', new THREE.BufferAttribute(sparkPositions, 3)); sparkGeom.setAttribute('aOffset', new THREE.BufferAttribute(sparkOffsets, 1));
            const connectorSparks = new THREE.Points(sparkGeom, connSparkMat); group.add(connectorSparks); return group;
        }
        const pcbGroupReal = buildDetailedPCB(); pcbGroup.add(pcbGroupReal);

        // --- 3. MODEL: ADAS CAR ---
        const adasGroup = new THREE.Group(); main3DGroup.add(adasGroup); adasGroup.scale.set(0,0,0);
        function buildCartoonCar() {
            const group = new THREE.Group();
            const bodyGroup = new THREE.Group();
            const mainBody = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 32), adasCarMat); mainBody.scale.set(0.6, 0.25, 1.2); mainBody.position.y = 0.25; bodyGroup.add(mainBody);
            const cabin = new THREE.Mesh(new THREE.SphereGeometry(0.5, 32, 32), adasCarMat); cabin.scale.set(0.9, 0.6, 1.2); cabin.position.set(0, 0.45, -0.1); bodyGroup.add(cabin);
            group.add(bodyGroup);
            const wheelGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.15, 32); wheelGeo.rotateZ(Math.PI/2);
            [{x: 0.6, z: 0.6}, {x: -0.6, z: 0.6}].forEach(pos => { const w = new THREE.Mesh(wheelGeo, adasCarMat); w.position.set(pos.x, 0.2, pos.z); group.add(w); });
            const rearWheel = new THREE.Mesh(wheelGeo, adasCarMat); rearWheel.position.set(0, 0.2, -0.7); group.add(rearWheel);
            const radarGeom = new THREE.PlaneGeometry(12, 12); const radarMesh = new THREE.Mesh(radarGeom, adasMat); radarMesh.rotation.x = -Math.PI / 2; radarMesh.position.y = 0.05; group.add(radarMesh);
            return group;
        }
        const adasCar = buildCartoonCar(); adasCar.scale.set(0.8, 0.8, 0.8); adasGroup.add(adasCar);

        // --- 4. MODEL: ÜNİVERSİTE LOGOSU (DÜZELTİLMİŞ VE KÜÇÜLTÜLMÜŞ YAZI) ---
        const uniGroup = new THREE.Group(); main3DGroup.add(uniGroup); uniGroup.scale.set(0,0,0);
        function buildUniLogo() {
            const group = new THREE.Group();
            const barW = 0.18; const barD = 0.18; const gap = 0.06;
            const positions = [{ x: -2*(barW+gap), h: 0.5 }, { x: -1*(barW+gap), h: 0.8 }, { x: 0, h: 1.1 }, { x: 1*(barW+gap), h: 0.8 }, { x: 2*(barW+gap), h: 0.5 }];
            positions.forEach(pos => { const geom = new THREE.BoxGeometry(barW, pos.h, barD); const mesh = new THREE.Mesh(geom, uniLogoMat); mesh.position.set(pos.x, pos.h / 2, 0); group.add(mesh); });
            
            const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
            canvas.width = 512; canvas.height = 64; // Canvas boyutunu küçülttük
            ctx.fillStyle = 'rgba(0,0,0,0)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.font = '300 20px Arial'; ctx.fillStyle = '#ffffff'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText('İSTANBUL MEDENİYET ÜNİVERSİTESİ', canvas.width / 2, canvas.height / 2);
            
            const tex = new THREE.CanvasTexture(canvas); tex.minFilter = THREE.LinearFilter;
            const textPlane = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 0.18), new THREE.MeshBasicMaterial({ map: tex, transparent: true, side: THREE.DoubleSide }));
            textPlane.position.set(0, -0.15, 0); group.add(textPlane); // Y konumunu ayarladık
            group.position.y = 0.2; return group;
        }
        const uniLogo = buildUniLogo(); uniGroup.add(uniLogo);


        // --- LOOP ---
        function update3DPosition() { const isMobile = window.innerWidth < 768; if(isMobile) { main3DGroup.rotation.set(0.1, 0, 0); main3DGroup.position.set(0, -1.0, -2.5); camera.position.set(0, 1.2, 7.5); } else { main3DGroup.rotation.set(0.2, -0.4, 0); main3DGroup.position.set(1.5, -0.5, 0); camera.position.set(0, 1.2, 5.5); } }
        update3DPosition(); camera.lookAt(0, 0.2, 0);
        window.addEventListener('mousemove', (e) => { if (chassisMaterial.uniforms.uOpacity.value > 0.1 && window.innerWidth > 768) { const x = (e.clientX / window.innerWidth) * 2 - 1; const y = (e.clientY / window.innerHeight) * 2 - 1; gsap.to(main3DGroup.rotation, { z: x * 0.1, x: 0.2 + y * 0.1, duration: 1 }); } });
        const clock = new THREE.Clock(); 
        function animate() { requestAnimationFrame(animate); const t = clock.getElapsedTime(); 
            [chassisMaterial, pcbBoardMat, connSparkMat, adasMat, adasCarMat, uniLogoMat].forEach(m => m.uniforms.uTime.value=t);
            chassisGroup.rotation.y+=0.002; pcbGroup.rotation.y+=0.002; adasGroup.rotation.y+=0.002; uniGroup.rotation.y += 0.002;
            renderer.render(scene, camera); } animate(); 
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); update3DPosition(); });

        // --- GSAP SCROLL ---
        gsap.registerPlugin(ScrollTrigger); const isMobile = window.innerWidth < 768;

        // 1. INTRO -> MECH
        gsap.to(".huge-intro-title", { y: -200, opacity: 0, scrollTrigger: { trigger: "#intro-section", start: "top top", end: "bottom top", scrub: 1 } });
        gsap.to(".scroll-hint", { opacity: 0, scrollTrigger: { trigger: "#intro-section", start: "10% top", end: "30% top", scrub: 1 } });
        gsap.to(chassisMaterial.uniforms.uOpacity, { value: 1.0, ease: "power1.inOut", scrollTrigger: { trigger: "#intro-section", start: "30% top", end: "80% top", scrub: 1 } });
        gsap.to(".ui-container-fixed", { opacity: 1, scrollTrigger: { trigger: "#showcase-section", start: "top center", end: "center center", scrub: 1 } });

        // 2. MECH SHOW -> MECH DETAIL
        const tlMech = gsap.timeline({ scrollTrigger: { trigger: "#details-section", start: "top bottom", end: "top top", scrub: 1 } });
        tlMech.to("#showcase-section .main-heading", { scale: isMobile ? 0.3 : 0.2, x: isMobile ? "0vw" : "-30vw", y: isMobile ? "-45vh" : "-30vh", opacity: 0, ease: "power2.inOut", duration: 1 }, 0);
        tlMech.to(".fixed-logo", { opacity: 1, duration: 1, ease: "power2.inOut" }, 0);
        tlMech.to("#showcase-section .sub-heading", { y: "85vh", x: "0vw", scale: 0.9, ease: "power2.inOut" }, 0);
        tlMech.to("#showcase-section .subtitle", { opacity: 0, duration: 0.5 }, 0);
        tlMech.to(main3DGroup.position, { x: isMobile ? 0 : 2.5, y: isMobile ? 1.5 : -0.5, z: isMobile ? -5.0 : -1.0, ease: "power2.inOut" }, 0);
        tlMech.to(".details-content", { opacity: 1, y: 0, duration: 0.5 }, 0.5);

        // 3. MECH DETAIL -> ELEC SHOW
        const tlElec = gsap.timeline({ scrollTrigger: { trigger: "#electronics-section", start: "top bottom", end: "center center", scrub: 1, onEnter: () => { document.getElementById("hud-div").innerText = "ELECTRONICS"; document.getElementById("hud-mat").innerText = "SILICON_PCB"; }, onLeaveBack: () => { document.getElementById("hud-div").innerText = "MECHANICS"; document.getElementById("hud-mat").innerText = "CFRP_COMPOSITE"; } } });
        tlElec.to(".details-content", { opacity: 0, y: -50, duration: 0.5 }, 0);
        tlElec.to("#showcase-section .sub-heading", { opacity: 0, duration: 0.5 }, 0);
        tlElec.to(chassisGroup.scale, { x: 0, y: 0, z: 0, duration: 1, ease: "power2.inOut" }, 0);
        tlElec.to(main3DGroup.rotation, { y: main3DGroup.rotation.y + Math.PI * 2, duration: 1, ease: "power2.inOut" }, 0);
        tlElec.fromTo(pcbGroup.scale, { x: 0, y: 0, z: 0 }, { x: 1, y: 1, z: 1, duration: 1, ease: "power2.inOut" }, 0);
        [pcbBoardMat, pcbChipMat, pcbSmdMat, pcbCopperMat, pcbWireMatRed, pcbWireMatBlack, connSparkMat].forEach(mat => { tlElec.to(mat.uniforms.uOpacity, { value: 1.0, duration: 0.5 }, 0.5); });
        tlElec.to(main3DGroup.position, { x: isMobile ? 0 : 1.5, y: isMobile ? -1.0 : -0.5, z: isMobile ? -2.5 : 0, ease: "power2.inOut" }, 0);

        // 4. ELEC SHOW -> ELEC DETAIL
        const tlElecDetails = gsap.timeline({ scrollTrigger: { trigger: "#electronics-details-section", start: "top bottom", end: "top top", scrub: 1, onEnter: () => { document.getElementById("hud-div").innerText = "ELECTRONICS"; } } });
        tlElecDetails.to("#electronics-section .sub-heading", { y: "85vh", x: "0vw", scale: 0.9, ease: "power2.inOut" }, 0);
        tlElecDetails.to("#electronics-section .subtitle", { opacity: 0, duration: 0.5 }, 0);
        tlElecDetails.to(main3DGroup.position, { x: isMobile ? 0 : 2.0, y: isMobile ? 1.5 : -0.5, z: isMobile ? -5.0 : -0.5, ease: "power2.inOut" }, 0);
        tlElecDetails.to("#electronics-details-section .details-content", { opacity: 1, y: 0, duration: 0.5 }, 0.5);

        // 5. ELEC DETAIL -> ADAS SHOW
        const tlAdas = gsap.timeline({
            scrollTrigger: {
                trigger: "#adas-section", start: "top bottom", end: "center center", scrub: 1,
                onEnter: () => { document.getElementById("hud-div").innerText = "ADAS_AI"; document.getElementById("hud-mat").innerText = "SENSOR_FUSION"; },
                onLeaveBack: () => { document.getElementById("hud-div").innerText = "ELECTRONICS"; document.getElementById("hud-mat").innerText = "SILICON_PCB"; }
            }
        });
        tlAdas.to("#electronics-details-section .details-content", { opacity: 0, y: -50, duration: 0.5 }, 0);
        tlAdas.to("#electronics-section .sub-heading", { opacity: 0, duration: 0.5 }, 0);
        tlAdas.to(pcbGroup.scale, { x: 0, y: 0, z: 0, duration: 1, ease: "power2.inOut" }, 0);
        tlAdas.to(main3DGroup.rotation, { y: main3DGroup.rotation.y + Math.PI * 2, duration: 1, ease: "power2.inOut" }, 0);
        tlAdas.fromTo(adasGroup.scale, { x: 0, y: 0, z: 0 }, { x: 1, y: 1, z: 1, duration: 1, ease: "power2.inOut" }, 0);
        tlAdas.to(adasMat.uniforms.uOpacity, { value: 1.0, duration: 0.5 }, 0.5);
        tlAdas.to(adasCarMat.uniforms.uOpacity, { value: 1.0, duration: 0.5 }, 0.5);
        tlAdas.to(main3DGroup.position, { x: isMobile ? 0 : 1.5, y: isMobile ? -1.0 : -0.5, z: isMobile ? -2.5 : 0, ease: "power2.inOut" }, 0);

        // 6. ADAS SHOW -> ADAS DETAILS
        const tlAdasDetails = gsap.timeline({ scrollTrigger: { trigger: "#adas-details-section", start: "top bottom", end: "top top", scrub: 1 } });
        tlAdasDetails.to("#adas-section .sub-heading", { y: "85vh", x: "0vw", scale: 0.9, ease: "power2.inOut" }, 0);
        tlAdasDetails.to("#adas-section .subtitle", { opacity: 0, duration: 0.5 }, 0);
        tlAdasDetails.to(main3DGroup.position, { x: isMobile ? 0 : 2.0, y: isMobile ? 1.5 : -0.5, z: isMobile ? -5.0 : -0.5, ease: "power2.inOut" }, 0);
        tlAdasDetails.to("#adas-details-section .details-content", { opacity: 1, y: 0, duration: 0.5 }, 0.5);

        // 7. ADAS DETAILS -> TEAM SHOWCASE (YENİ SAYFA 1 GEÇİŞİ)
        const tlTeamShowcase = gsap.timeline({
            scrollTrigger: {
                trigger: "#team-showcase-section", start: "top bottom", end: "center center", scrub: 1,
                onEnter: () => { document.getElementById("hud-div").innerText = "THE_TEAM"; document.getElementById("hud-mat").innerText = "ACADEMIC"; },
                onLeaveBack: () => { document.getElementById("hud-div").innerText = "ADAS_AI"; document.getElementById("hud-mat").innerText = "SENSOR_FUSION"; }
            }
        });
        tlTeamShowcase.to("#adas-details-section .details-content", { opacity: 0, y: -50, duration: 0.5 }, 0);
        tlTeamShowcase.to("#adas-section .sub-heading", { opacity: 0, duration: 0.5 }, 0);
        tlTeamShowcase.to(adasGroup.scale, { x: 0, y: 0, z: 0, duration: 1, ease: "power2.inOut" }, 0);
        tlTeamShowcase.to(main3DGroup.rotation, { y: main3DGroup.rotation.y + Math.PI * 2, duration: 1, ease: "power2.inOut" }, 0);
        tlTeamShowcase.fromTo(uniGroup.scale, { x: 0, y: 0, z: 0 }, { x: 1, y: 1, z: 1, duration: 1, ease: "power2.inOut" }, 0);
        tlTeamShowcase.to(uniLogoMat.uniforms.uOpacity, { value: 1.0, duration: 0.5 }, 0.5);
        tlTeamShowcase.to(main3DGroup.position, { x: isMobile ? 0 : 2.0, y: isMobile ? -0.5 : -0.5, z: isMobile ? -2.5 : 1.0, ease: "power2.inOut" }, 0); // Logoyu sağa al

        // 8. TEAM SHOWCASE -> TEAM DETAILS (YENİ SAYFA 2 GEÇİŞİ)
        const tlTeamDetails = gsap.timeline({ scrollTrigger: { trigger: "#team-details-section", start: "top bottom", end: "top top", scrub: 1 } });
        tlTeamDetails.to("#team-showcase-section .sub-heading", { y: "85vh", x: "0vw", scale: 0.9, ease: "power2.inOut" }, 0);
        tlTeamDetails.to("#team-showcase-section .subtitle", { opacity: 0, duration: 0.5 }, 0);
        // Logo konumunu koru (sağda)
        tlTeamDetails.to(main3DGroup.position, { x: isMobile ? 0 : 2.0, y: isMobile ? -0.5 : -0.5, z: isMobile ? -2.5 : 1.0, ease: "power2.inOut" }, 0);
        tlTeamDetails.to("#team-details-section .details-content", { opacity: 1, y: 0, duration: 0.5 }, 0.5);

    </script>
</body>
</html>
